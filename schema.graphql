type User {
  userId: ID
  name: String
  email: String!
  password: String!
  active: Boolean
  exists: Boolean
  rol:String
  employeeNumber: String
  area: Works
  groups: [Belongs]
  publications:[Writes]
  comments: [Makes]
}

type Area{
areaId:ID!
name: String
members: [Works]
active: Boolean
department:Indepartment
}

type Department {
  departmentId: ID!
  name: String
  active: Boolean
  areas: [Indepartment]
}

type Group {
  groupId: ID!
  name: String!
  privacidad:Boolean!
  active: Boolean!
  members: [Belongs]
}

type Publication{
publicationId:ID
text: String
author: Writes
comments:[Comments]

}

type Comment{
commentId:ID
text: String
commen: Comments
user:Makes
}

type Works @relation(name: "WORKS") {
  from: User
  to: Area
  role: String
}

type Indepartment @relation(name: "IN_DEPARTMENT") {
  from: Area
  to: Department
  role: String
}

type Writes @relation(name: "WRITES") {
 from: User
 to: Publication
 date: String
}

type Comments @relation(name: "COMMENTS") {
 from: Comment
 to: Publication
 date: String
}

type Makes @relation(name: "MAKES") {
 from: User
 to: Comment
 date: String
}

type Belongs @relation(name: "BELONGS") {
  from: User
  to: Group
  role: String
}

type Token {
  token: String
}

input AuthInput {
  email: String!
  password: String!
}

input UserInput {
  userId: ID
  name: String
  email: String!
  password: String!
  active: Boolean
  exists: Boolean
  employeeNumber: String
  rol:String
}

input GroupInput {
  groupId: ID!
  name: String!
  active: Boolean!
}

input PublicationInput {
  author: String!
  text: String!
  publicationId:ID
}

input CommentInput {
  author: String!
  commentId:ID
  text: String!
  publicationId: ID
}


input DepartmentInput {
  departmentId: ID!
  name: String!
  active: Boolean
}

input AreaInput{
  areaId:ID!
  name: String
  active: Boolean
}

input UserToAreaInput{
  areaId: ID!
  userId: ID
  name: String
  email: String!
  password: String!
  active: Boolean
  exists: Boolean
  employeeNumber: String
  rol:String
}

type Query {
  allUser(first: Int = 4, offset: Int = 0): [User]
  userByname(name: String, idUser: ID = 1000): [User]
    @cypher(
      statement: "MATCH (u:User) WHERE u.name CONTAINS $name  OR u.userId CONTAINS $idUser return u"
    )
  userById(id: ID!): User
  obtenerUsuario(token: String!): User
  getUser:User
  SearchLeader(users: [ID]): [User]
}

type Mutation {
  newUser(input: UserInput): User
  mergeUserToDepartmen(userIds: ID!, departmentIds: ID!): Department
    @cypher(
      statement: "MATCH (u:User {userId:$userIds}) MATCH (d:Department {departmentId:$departmentIds}) MERGE (u)-[:WORKS]->(d) return d"
    )

  authUser(input: AuthInput): Token
  updateUser(input: UserInput): User
  CreateUserAndAddtoArea(input:UserToAreaInput): User
  CreaGroupAndAddUsers(users: [ID], creator:ID, inputGroup: GroupInput): Group
  MakePublication(input: PublicationInput):Publication
  CommentPublication(input: CommentInput):Comment
  AddUsersToArea(input:ID):Area
  CreateAreaAndAddUsers(users:[ID], areaInput: AreaInput,departmentId:ID):Area
}
